---
title: "ã‚¬ã‚¤ã‚¹ã‚¿ãƒ¼ã‚¢ãƒ—ãƒªé–‹ç™º(4) åˆæœŸç›¤é¢"
date: 2020-12-19T12:00:00+09:00
lastmod: 2021-01-01T12:00:00+09:00
categories: [ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°, ã‚¬ã‚¤ã‚¹ã‚¿ãƒ¼ã‚¢ãƒ—ãƒªé–‹ç™º]
tags: [ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°, Python, ã‚¢ãƒ—ãƒªé–‹ç™º]
draft: false
---

Python ã§ã¤ãã‚‹ã‚¬ã‚¤ã‚¹ã‚¿ãƒ¼ã€é€£è¼‰ç¬¬ 4 å›ã§ã™ã€‚

{{< pstlk å‰å› geister-app-dev-3 >}}ã¯ãƒã‚¦ã‚¹æ“ä½œã§é§’ã®åˆæœŸé…ç½®ã‚’æ±ºã‚ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚

ä»Šå›ã¯ã‚²ãƒ¼ãƒ æœ¬ç•ªã§ã®åˆæœŸç›¤é¢ã‚’æç”»ã™ã‚‹ã¨ã“ã‚ã¾ã§ã‚„ã£ã¦ã„ãã¾ã™ã€‚

<!--more-->

<br/>

## ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«åˆ‡ã‚Šåˆ†ã‘ã‚‹

é§’ã®åˆæœŸé…ç½®ã‚’æ±ºå®šã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨ã€ã‚²ãƒ¼ãƒ æœ¬ç•ªã§ã®å‹•ä½œã‚’è¦å®šã™ã‚‹ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’åˆ†ã‘ã¦æ›¸ããŸã„ã®ã§ã€

å…±é€šéƒ¨åˆ†ã ã‘`main.py`ã«ç½®ã„ã¦ã€ãã“ã‹ã‚‰å„ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’å‘¼ã³å‡ºã™å½¢ã«ã—ã¾ã™ã€‚

<details>
<summary><code>setup.py</code></summary><br/>
```py {name="setup.py"}
import sys

import pygame
from pygame.locals import *

from config import IVORY
import draw, mouse


def _check_color(colors):
    '''
    é§’ãŒã™ã¹ã¦é…ç½®æ¸ˆã¿ã§èµ¤ã¨é’ãŒåŠåˆ†ãšã¤ã‚ã‚‹ã‹
    -> bool

    colors : list <- [str]
        è‰²ã®ãƒªã‚¹ãƒˆ
    '''
    return (len(colors) == 8
        and len([s for s in colors if s == 'R'])
            == len([s for s in colors if s == 'B']))


def main(screen, font, select_snd, decide_snd, forbid_snd):
    # é…ç½®ã‚’æ±ºå®šã™ã‚‹å´
    # 0 - å…ˆæ”», 1 - å¾Œæ”»
    _state = 0
    # æ±ºå®šã•ã‚ŒãŸåˆæœŸé…ç½®
    # [{(int, int): Piece}]
    _order = [{}, {}]

    while True:
        satisfied = _check_color(list(_order[_state].values()))

        screen.fill(IVORY)
        draw.setup(screen, font, _state, _order[_state], not satisfied)
        pygame.display.update()

        # ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
        for event in pygame.event.get():
            # é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³
            if event.type == QUIT:
                pygame.quit()
                sys.exit()
            # ãƒã‚¦ã‚¹ã‚¯ãƒªãƒƒã‚¯
            if event.type == MOUSEBUTTONDOWN:
                # å·¦
                if event.button == 1:
                    _mouse_pos = event.pos
                    _square_pos = tuple(mouse.chcoord(_mouse_pos))

                    for i in range(1, 5):
                        for j in range(2, 4):
                            if _square_pos == (i, j):
                                select_snd.play()
                                _order[_state][(i, j)] = 'R'
                    
                    if mouse.on_area(*_mouse_pos, 500, 530, 80, 50):
                        if satisfied:
                            decide_snd.play()
                            _state += 1
                        else:
                            forbid_snd.play()
                # å³
                elif event.button == 3:
                    _mouse_pos = event.pos
                    _square_pos = tuple(mouse.chcoord(_mouse_pos))

                    for i in range(1, 5):
                        for j in range(2, 4):
                            if _square_pos == (i, j):
                                select_snd.play()
                                _order[_state][(i, j)] = 'B'
            # ã‚­ãƒ¼
            if event.type == KEYDOWN:
                # Esc ã‚­ãƒ¼
                if event.key == K_ESCAPE:
                    pygame.quit()
                    sys.exit()
```

</details>

<details>
<summary><code>game.py</code></summary><br/>
```py {name="game.py"}
import sys

import pygame
from pygame.locals import *

from config import IVORY


def main(screen):
    while True:
        screen.fill(IVORY)
        pygame.display.update()

        # ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
        for event in pygame.event.get():
            # é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³
            if event.type == QUIT:
                pygame.quit()
                sys.exit()
            # ã‚­ãƒ¼
            if event.type == KEYDOWN:
                # Esc ã‚­ãƒ¼
                if event.key == K_ESCAPE:
                    pygame.quit()
                    sys.exit()
```

</details>

<details>
<summary><code>main.py</code></summary><br/>
```py {name="main.py", hl_lines=["21-22"]}
import sys

import pygame
from pygame.locals import *

from config import DISP_SIZE
import setup, game


if __name__ == '__main__':
    pygame.init()
    # éŸ³å£°ã®è¨­å®š
    snd = pygame.mixer.Sound
    select_snd = snd('./sounds/select.wav')
    decide_snd = snd('./sounds/decide.wav')
    forbid_snd = snd('./sounds/forbid.wav')

    pygame.display.set_caption('Geister')
    font = pygame.font.SysFont('hgä¸¸ï½ºï¾ï½¼ï½¯ï½¸mpro', 16)

    setup.main(screen, font, select_snd, decide_snd, forbid_snd)
    game.main(screen)
```

</details>

<br/>

`setup.py`ã§ã®`while`ãƒ«ãƒ¼ãƒ—ãŒçµ‚äº†ã™ã‚Œã°`game.py`ã§ã®ãƒ«ãƒ¼ãƒ—ãŒé–‹å§‹ã—ã¾ã™ã€‚

<br/>

## é§’ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆã™ã‚‹

ç›¤é¢ã®ãƒ‡ãƒ¼ã‚¿ã¯ã€ä½ç½®ï¼šé§’ã®è¾æ›¸å‹ã«ã™ã‚‹ã“ã¨ã«ã—ã¾ã™ã€‚

é§’ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦ã€ã©ã¡ã‚‰å´ã®é§’ã‹ã€è‰²ã¯ä½•ã‹ãªã©ã®å±æ€§ã‚’æŒãŸã›ã¾ã™ã€‚

```py {name="piece.py"}
import numpy as np

class Piece:
    def __init__(self, color, side):
        self.color = color  # èµ¤('R') or é’('B')
        self.side = side    # å…ˆæ”»(0) or å¾Œæ”»(1)
    
    def __repr__(self):
        return self.color + str(self.side)
    
    def covering_squares(self, pos):
        '''
        å¯èƒ½ãªç§»å‹•å…ˆã®ãƒã‚¹ã®ãƒªã‚¹ãƒˆ
        -> list <- [(int, int)]

        pos : tuple <- (int, int)
            ç¾åœ¨ã®ä½ç½®
        '''
        pos_ = np.asarray(pos) + [(0, 1), (0, -1), (-1, 0), (1, 0)]
        dest = [(x, y) for x, y in pos_ if 0 <= x <= 5 and 0 <= y <= 5]
        if self.color == 'B':
            if self.side == 0:
                if pos == (0, 0):
                    dest += [(0, -1)]
                if pos == (5, 0):
                    dest += [(5, -1)]
            elif self.side == 1:
                if pos == (0, 5):
                    dest += [(0, 6)]
                if pos == (5, 5):
                    dest += [(5, 6)]

        return dest
```

`__repr__`ãƒ¡ã‚½ãƒƒãƒ‰ã¯ãƒ‡ãƒãƒƒã‚°ã®ã¨ãã«å½¹ç«‹ã¡ã¾ã™ã€‚

`print`ã—ãŸã¨ãã«å‡ºåŠ›ã•ã‚Œã‚‹æ–‡å­—åˆ—ã‚’è¿”ã—ã¾ã™ãŒã€ã“ã‚ŒãŒãªã„ã¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆidã ã‘ã‚’è¿”ã™ã®ã§å±æ€§ã®æƒ…å ±ãŒã‚ã‹ã‚Šã¥ã‚‰ããªã‚Šã¾ã™ã€‚

<br/>

`convering_squares`ãƒ¡ã‚½ãƒƒãƒ‰ã®æ¡ä»¶åˆ†å²ã¯ã€è‰¯ã„ãŠã°ã‘ãŒç›¸æ‰‹ã®é™£åœ°ã®è§’ã‹ã‚‰è„±å‡ºã™ã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã‚‚ã®ã§ã™ã€‚

<br/>

## åˆæœŸç›¤é¢ã‚’ç”Ÿæˆã™ã‚‹

ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é…ç½®ã‹ã‚‰åˆæœŸç›¤é¢ã‚’ç”Ÿæˆã™ã‚‹é–¢æ•°ã‚’ä½œã‚Šã¾ã™ã€‚

```py {name="setup.py"}
...
from piece import Piece
...

def _init_board(order1, order2):
    '''
    é§’ã®é…ç½®ã‹ã‚‰åˆæœŸç›¤é¢ã‚’å‡ºåŠ›
    -> dict <- {(int, int): Piece}

    order1, order2 : dict <- {(int, int): str}
        é§’ã®åˆæœŸé…ç½®. order1 ãŒå…ˆæ”»
    '''
    return {**{(5-x, 3-y): Piece(s, 1) for (x, y), s in order2.items()},
        **{(x, y+2): Piece(s, 0) for (x, y), s in order1.items()}}

```

ç›¤é¢ã¯å·¦ä¸ŠãŒ`(0, 0)`ã‹ã‚‰å³ä¸‹ãŒ`(5, 5)`ã¾ã§ã§åº§æ¨™ã‚’å–ã£ã¦ã„ã¦ã€

é§’ã®ä½ç½®ã¯å…ˆæ‰‹ãŒ`(1, 4)`ã‹ã‚‰`(4, 5)`ã€å¾Œæ‰‹ãŒ`(1, 0)`ã‹ã‚‰`(4, 1)`ã¾ã§ã¨ãªã‚Šã¾ã™ã€‚

ãƒã‚¦ã‚¹ã§ç™»éŒ²ã—ãŸã¨ãã«ã¯å·¦ä¸Š`(1, 2)`ã€å³ä¸‹`(4, 3)`ã«ãªã£ã¦ã„ã‚‹ã®ã§ã€åº§æ¨™ã‚’å¤‰æ›ã—ã¦ã„ã¾ã™ã€‚

å…ˆæ‰‹ã¯å¹³è¡Œç§»å‹•ã ã‘ã§ã™ãŒã€å¾Œæ‰‹ã¯180åº¦å›è»¢ã‚‚ã—ã¦ã„ã¾ã™ã€‚

<br/>

ã“ã‚Œã§`_init_board(*_order)`ã¨ã™ã‚Œã°ã€åˆæœŸç›¤é¢ã‚’è¿”ã™ã“ã¨ãŒã§ãã¾ã™ã€‚

ã“ã‚Œã‚’`setup.main()`ã®è¿”ã‚Šå€¤ã¨ã—ã¦`main.py`ã«æ¸¡ã—ã€

ã•ã‚‰ã«`game.py`ã«å¼•æ•°ã¨ã—ã¦æ¸¡ã™ã“ã¨ã§ç›¤é¢ã‚’æç”»ã—ã¦ã„ãã¾ã™ã€‚

```py {name="setup.py", hl_lines=[14]}
...
        # ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
        for event in pygame.event.get():
            ...
            # ãƒã‚¦ã‚¹ã‚¯ãƒªãƒƒã‚¯
            if event.type == MOUSEBUTTONDOWN:
                # å·¦
                if event.button == 1:
                    ...
                    
                    if mouse.on_area(*_mouse_pos, 500, 530, 80, 50):
                        if satisfied:
                            decide_snd.play()
                            if _state == 1: return _init_board(*_order)
                            _state += 1
                        ...
```

```py {name="main.py", hl_lines=["4-5"], inline_hl=[0:["0-1"], 1:["5-6"]]}
...
if __name__ == '__main__':
    ...
    orders = setup.main(screen, font, select_snd, decide_snd, forbid_snd)
    game.main(screen, orders)
```

```py {name="game.py", hl_lines=[2], inline_hl=[0:["4-5"]]}
...
def main(screen, orders):
    ...
```

### ç›¤é¢ã‚’æç”»ã™ã‚‹

ã•ã¦ã€ç›¤é¢ã‚’æç”»ã™ã‚‹é–¢æ•°ã‚’å®šç¾©ã—ã¦ã„ãã¾ã™ã€‚

ã‚¬ã‚¤ã‚¹ã‚¿ãƒ¼ã§ã¯è‰¯ã„ãŠã°ã‘ãŒç›¤ã®è§’ã‹ã‚‰å¤–ã«å‡ºã‚‹ã¨å‹ã¡ã¨ã„ã†ãƒ«ãƒ¼ãƒ«ãŒã‚ã‚‹ã®ã§ã€

è§’ã«çŸ¢å°ã‚’æã„ã¦ã„ã¾ã™ã€‚

```py {name="draw.py"}
...
def _arrow(screen, coord, direction):
    '''
    çŸ¢å°ã‚’æã

    screen : pygame.display.set_mode
    coord : tuple <- (int, int)
        çŸ¢å…ˆã®åº§æ¨™
    direction : str <- 'U', 'D'
        'U' - ä¸Š, 'D' - ä¸‹
    '''
    assert direction == 'U' or direction == 'D',\
        'draw._arrow ã®å¼•æ•° direction ã¯ "U", "D" ã®å€¤ã‚’å–ã‚Šã¾ã™'
    _coord = np.asarray(coord)
    if direction == 'D':
        pygame.draw.line(screen, BLACK,
            _coord, _coord + (PIECE_SIZE/2, -PIECE_SIZE/2), 2)
        pygame.draw.line(screen, BLACK,
            _coord, _coord - (PIECE_SIZE/2, PIECE_SIZE/2), 2)
        pygame.draw.line(screen, BLACK,
            _coord, _coord - (0, PIECE_SIZE), 2)
    else:
        pygame.draw.line(screen, BLACK,
            _coord, _coord + (PIECE_SIZE/2, PIECE_SIZE/2), 2)
        pygame.draw.line(screen, BLACK,
            _coord, _coord + (-PIECE_SIZE/2, PIECE_SIZE/2), 2)
        pygame.draw.line(screen, BLACK,
            _coord, _coord + (0, PIECE_SIZE), 2)
...
def board(screen, board, turn):
    '''
    ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ã¨ç›¤é¢ä¸Šã®é§’ã‚’æã

    screen : pygame.display.set_mode
    board : dict <- {(int, int): Piece}
        é§’ã®ä½ç½®ã¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
    turn : int <- 0, 1, 2
        0 - å…ˆæ”»ã®é§’ã‚’é–‹ã, 1 - å¾Œæ”»ã®é§’ã‚’é–‹ã, 2 - ä¸¡æ–¹é–‹ã,
    '''
    assert turn == 0 or turn == 1 or turn == 2, 'draw.board ã®å¼•æ•° turn ã¯ 0, 1, 2 ã®å€¤ã‚’å–ã‚Šã¾ã™'
    # ã‚°ãƒªãƒƒãƒ‰
    _grid(screen, MARGIN, 6, 6)
    # è§’ã®çŸ¢å°
    _padding = (SQUARE_SIZE - PIECE_SIZE)/2
    _arrow(screen, MARGIN+(SQUARE_SIZE/2, _padding), 'U')
    _arrow(screen, MARGIN+(11*SQUARE_SIZE/2, _padding), 'U')
    _arrow(screen, DISP_SIZE-MARGIN-(SQUARE_SIZE/2, _padding), 'D')
    _arrow(screen, DISP_SIZE-MARGIN-(11*SQUARE_SIZE/2, _padding), 'D')
    # é§’
    for pos, piece in board.items():
        if turn == 2:
            if piece.side == 0:
                _piece(screen, RED if piece.color == 'R' else BLUE, pos)
            else:
                _piece(screen, RED if piece.color == 'R' else BLUE, pos, True)
        elif turn == 0:
            if piece.side == 0:
                _piece(screen, RED if piece.color == 'R' else BLUE, pos)
            else:
                _piece(screen, GREY, pos, True)
        elif turn == 1:
            if piece.side == 0:
                _piece(screen, GREY, pos)
            else:
                _piece(screen, RED if piece.color == 'R' else BLUE, pos, True)
```

`BLACK`ã‚„`GREY`ã¯è‰²ã®å®šæ•°ã§ã€`config.py`ã«å®šç¾©ã—ã¦ã„ã¾ã™ã€‚

<br/>

ã“ã‚Œã‚’`game.py`ã§å‘¼ã³å‡ºã—ã¾ã™ã€‚

```py {name="game.py", hl_lines=[10]}
...
import draw
...
def main(screen, orders):
    # ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ {(int, int): Piece}
    _board = orders

    while True:
        screen.fill(IVORY)
        draw.board(screen, _board, 0)
        pygame.display.update()
        ...
```

ã“ã‚Œã§é§’ã®é…ç½®ã‚’æ±ºå®šã—ãŸã‚ã¨ã«ã€åˆæœŸç›¤é¢ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚

{{< img src=board alt="åˆæœŸç›¤é¢" >}}

---

{{< pstlk æ¬¡å› geister-app-dev-5 >}}ã¯é§’ã®ç§»å‹•ã¨ã‚¿ãƒ¼ãƒ³äº¤ä»£æ™‚ã®ç”»é¢ã‚’ç”¨æ„ã—ã¾ã™ã€‚

èª­ã‚“ã§ãã‚Œã¦ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸã€‚

ã§ã¯ğŸ‘‹
